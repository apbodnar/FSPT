<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Blinn Phong Ping Pong</title>
<style>
  body{ text-align: center; margin: 0; overflow: hidden; background: #000;}
  canvas{ border: none; }
</style>
<script id="FRAGMENT_SHADER" type="x-shader/x-fragment">
  precision highp float;
  const int sphereCount = 14;
  const float max_t = 100000.0;
  const float n1 = 1.0;
  const float n2 = 1.458;
  const float sr = n1/n2;
  const float r0 = ((n1 - n2)/(n1 + n2))*((n1 - n2)/(n1 + n2));
  const float M_PI = 3.1415926535897932384626433832795;
  const float epsilon = 0.00001; //not really epsilon

  varying vec2 coords;
  uniform int mode;
  uniform int tick;
  uniform vec2 dims;
  uniform vec3 eye;
  uniform vec3 spherePositions[sphereCount];
  uniform vec3 sphereAttrs[sphereCount];
  uniform vec3 sphereMats[sphereCount];
  uniform vec3 sphereColors[sphereCount];
  uniform sampler2D fbTex;

  float tick_f = float(tick);

  struct Sphere {
    vec3 pos;
    vec3 attrs;
    vec3 color;
    vec3 material;
  };

  struct Hit{
    float t;
    vec3 pos;
    vec3 dir;
    vec3 normal;
    vec3 emmittance;
    vec3 reflectance;
    int index;
  };

  struct Ray{
    vec3 origin;
    vec3 dir;
  };

  float rand(vec2 co){
    float a = 12.9898;
    float b = 78.233;
    float c = 43758.5453;
    float dt= dot(co ,vec2(a,b));
    float sn= mod(dt,M_PI);
    return fract(sin(sn) * c);
  }

  float getAngle(vec3 a){
    vec3 b = vec3(0.0,0.0,1.0);
    return atan(length(cross(a,b)),a.z);
  }

  mat3 rotationMatrix(vec3 axis, float angle){
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    return mat3(oc * axis.x * axis.x + c,    oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,
          oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,
          oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);
  }

  vec3 randomVec(vec3 normal, vec3 pos){
    float r2 = rand(pos.xz+tick_f*0.0194161103873);
    float r1 = rand(pos.xy+tick_f*0.0115572734979)-epsilon;
    float r = sqrt(r1);
    float theta = 2.0 * M_PI * r2;
    float x = r * cos(theta);
    float y = r * sin(theta);
    vec3 rv = vec3(x, y, sqrt(1.0 - r1));
    float phi = getAngle(normal);
    return rotationMatrix(cross(normal,vec3(0.0,0.0,1.0)),phi) * rv;
  }

  // vec3 randomVec(vec3 normal, vec3 pos){
  //   vec3 tc = vec3(rand(pos.xy+tick_f*0.01329),rand(pos.xz+tick_f*0.07347),rand(pos.yz+tick_f*0.003391));
  //   return normalize(dot(tc,normal) > 0.0 ? tc : -tc);
  // }

  float checkSphereCollision(Ray ray,Sphere s){
    float scalar = dot(ray.dir,ray.origin - s.pos);
    float dist = distance(ray.origin, s.pos);
    float squared = (scalar * scalar) - (dist * dist) + (s.attrs.r * s.attrs.r);
    return squared < 0.0 ? max_t : -scalar - sqrt(squared);
  }

  Hit getCollision(Ray ray, int current){
    float t = max_t;
    Hit result = Hit(max_t,vec3(0,0,0),vec3(0,0,0),vec3(0,0,0),vec3(0,0,0),vec3(0,0,0),-1);
    for(int i=0; i<sphereCount; i++){
      Sphere s = Sphere(spherePositions[i],sphereAttrs[i],sphereColors[i],sphereMats[i]);
      float radius = s.attrs.r;
      float nt = checkSphereCollision(ray,s);
      if(nt < result.t && nt > 0.0 && current != i){
        result.t = nt;
        result.pos = ray.dir*nt + ray.origin;
        result.normal = normalize(result.pos - s.pos);
        result.emmittance = s.attrs.z * s.color;
        result.index = i;
        if( int(s.material.z) == 0 ){ //diffuse
          result.dir = randomVec(result.normal, result.pos);
          result.reflectance = s.color;
        } else if( int(s.material.z) == 1 ){ //transmissive
          float dh = 1.0 - dot(-ray.dir,result.normal);
          float re = r0 + (1.0 - r0)*dh*dh*dh*dh*dh;
          if(rand(result.pos.xy + tick_f*0.0017839) < re){
            result.dir = reflect(ray.dir, result.normal);
          }else{
            float c = dot(ray.dir,-result.normal);
            vec3 ref = normalize(sr*ray.dir + (sr*c - sqrt(1.0 - sr*sr*(1.0 - c*c)))*result.normal);
            result.pos = ref*dot(ref,result.normal)*radius*2.0 + result.pos;
            result.dir = reflect(-ray.dir,ref);
          }
          result.reflectance = vec3(1);
        }
      }
    }
    return result;
  }

  void main(void) {
    vec3 tcolor = texture2D(fbTex,coords*0.5 + 0.5).rgb;
    if(mode == 0){
      vec2 dof = vec2((rand(coords-tick_f*0.02571)+0.5)*0.002,
                      (rand(coords.yx+tick_f*0.005831)+0.5)*0.002);
      vec3 origin = vec3(coords.x*dims.x/dims.y + dof.x,coords.y + dof.y,0);
      Ray ray = Ray(origin,normalize(origin - eye));
      int index = -1;
      vec3 color = vec3(0,0,0);
      //No recursion in GLSL
      Hit r0 = getCollision(ray,index);
      Hit r1 = getCollision(Ray(r0.pos,r0.dir),r0.index);
      Hit r2 = getCollision(Ray(r1.pos,r1.dir),r1.index);
      Hit r3 = getCollision(Ray(r2.pos,r2.dir),r2.index);
      Hit r4 = getCollision(Ray(r3.pos,r3.dir),r3.index);
      color = (r0.emmittance + r0.reflectance *
              (r1.emmittance + r1.reflectance *
              (r2.emmittance + r2.reflectance *
              (r3.emmittance + r3.reflectance *
              (r4.emmittance)))));
      gl_FragColor = abs(vec4((color + (tcolor * tick_f))/(tick_f+1.0),1.0));
    } else {
      gl_FragColor = abs(vec4(tcolor,1.0));
    }
  }
</script>

<script id="VERTEX_SHADER" type="x-shader/x-vertex">
  precision highp float;
  attribute vec3 corner;
  varying vec2 coords;
  void main(void) {
    coords = corner.xy;
    gl_Position = vec4(corner, 1.0);
  }
</script>
<script src="fspt.js" type="text/javascript"></script>
</head>


<body onload="webGLStart();">
  <canvas id="trace" style="border: none;"></canvas>
</body>

</html>
